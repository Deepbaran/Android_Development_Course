//What the inline function does is that, it will copy all the code to the call site.
//Compiler copies all the code of a inline function to wherever it is called.
inline fun <reified T> checkTypeAtRuntime(item: Any) {
    //The T will be erased at runtime as it is a generic type.
    //To know the type of T during runtime we will have to make the function a inline function and use the modifier "reified".
    //Now, we will have information, what was the type parameter.
    println("${item is T}")
}

fun main() {
    val names: MutableList<String> = mutableListOf("John", "Sarah", "Mark")
    val ages: MutableList<Int> = mutableListOf(1, 2, 3)
    //Even though, names and ages are given a proper type, they will be converted to lists in runtime, during runtime there would be no way to tell their types.
    //That is, their types will get erased in runtime. And we cannot find what type the mutable list was.

    checkTypeAtRuntime<String>("John")
    //As checkTypeAtRuntime is a inline functions, so during compilation all the function code will be copied here by the compiler.
    //The above code will be converted to the below code by the compiler during compile time and get executed during runtime:
    /*println("${item is T}")*/ //Body of the inline checkTypeAtRuntime function
    //As it comes here in the compile time, so the compiler does the following before runtime:
    /*println("John" is String)*/ //This is how we can know the type of the generic during runtime

    checkTypeAtRuntime<Int>("Sarah")
    //This code will be replaced by compiler in the following code:
    /*println("Sarah" is Int)*/
}

/*
You can only use reified in combination with an inline function.
By doing so, you instruct the compiler to copy the function's bytecode to every spot the function is invoked from (the compiler "inlines" the function).
When you call an inline function with reified type, the compiler has to be able to know the actual type passed as a type argument so that it can modify the generated bytecode to use the corresponding class directly.
Therefore a call like myVar is T becomes myVar is String in the bytecode (if the type argument is String).
 */

/*
The below code will give error:

fun printVal<T: Any>(value:T){
    if(value is Number){ //T will be erased at runtime, so we will not be able to know the type of value and it will give error. Use inline and reified to prevent the error
        println("Number value: $value")
    }
}
fun main(){
    printVal(5)
}
 */